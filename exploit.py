from pwn import *  
# Function to break the encrypted output into chucks of 32 bytes
def chunks(data, size):
    for i in range(0, len(data), size):
            yield data[i:i+size]
HOST = ""
PORT = 9999
 
# This is the layout:
# Beginning:
 
# agent cccccccccc 
# c wants to see x <-- The block I am comparing where x is the byte I am brute-forcing
# cccccccccccccccc
# cccccccccccccccc end_padding (Leaving space for the whole flag to reveal
# cccccccccccccccc
# cccccccccccccccc
# c wants to see x <-- The block I am comparing

# Close to the end:
 
# agent c3c2dffdec
# 5a1107bca11e26_!
# cccccccccccccccc
# cccccccccccccccc
# wants to see d7
# 2ab5a083c2dffdec
# 5a1107bca11e26_E


flag = b""
start_padding = b'c' * 11 + b" wants to see "
end_padding = 65

while True:
    for guess in range(32, 256):
        conn = remote(HOST, PORT)

        # Read and ignore the initial banner and prompt (you can read until the prompt if known)
        conn.recvuntil(b': ')
 
        # Send input string
        conn.sendline(start_padding + bytes([guess]) + b'c' * end_padding)
        print(b"Trying: " + start_padding + bytes([guess]) + b'c' * end_padding)
        # Receive the response after sending input
        response = conn.recvline(timeout=2)
        blocks = list(chunks(response.decode(), 32))
         
        guess_block = blocks[1] if len(blocks) > 1 else b''
        check_block = blocks[6] if len(blocks) > 6 else b''
 
        if guess_block == check_block:
            print(b'Found: '+bytes([guess]))
            flag += bytes([guess])
            if len(flag) == 49: # This is the length of the flag I am looking to crack. Change according to your needs
                print("Flag: "+flag)
                conn.close()
                exit(0)
            start_padding += bytes([guess])
            start_padding = start_padding[1:]
            end_padding -= 1
            break
        conn.close()
